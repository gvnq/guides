Positioning Applied - Layout And Sizing
=======================================

Layout in Famo.us is managed by `Transforms` and `Modifiers`. `Transforms` 
encapsulate the [CSS3 transform specification](https://developer.mozilla.org/en-US/docs/Web/CSS/transform), that allow for positioning and orienting in 3D space. While a `Transform` is a static object, `Modifiers` encapsulate 
varying `Transforms` over time, as well as bundling convenient layout properties like `size` and `origin` that we will go over below.

Overview
================================================================================

- [Modifiers](#modifiers)
  - [Transforms](#transform)
  - [Size](#size)
  - [Origin](#origin)
- [Review](#review)

<a name="modifiers">Modifiers</a>
--------------------------------------------------------------------------------

A `Modifier` is a Famo.us node that can be added to the Render Tree. `Modifiers` modify all the nodes below them.
They are defined by holding on to four states: `size`, `transform`, `origin`, and `opacity`. These correspond to the 
hardware accelerated properties that Famo.us can change at 60 FPS.

<a name="transform">Transform</a>
--------------------------------------------------------------------------------
`Transforms` are sixteen-element arrays that correspond directly to a CSS3 transformation matrix. This matrix encodes
a translation, rotation, scale and skew state.

#####Transform.Identity
The default `Transform` is `Transform.identity`, which has no effect on layout. It is like multiplying a number by 1.

The identity transform looks like this:

```js
  [1, 0, 0, 0,
   0, 1, 0, 0,
   0, 0, 1, 0,
   0, 0, 0, 1]
```

#####Transform.translate(x, y, z)
The `.translate` API allows a user to perform a translation in 3D space of the Render Tree below. The translate transform looks like this:

```js
  [1, 0, 0, 0,
   0, 1, 0, 0,
   0, 0, 1, 0,
   x, y, z, 1]
```

#####Transform.Scale(x, y, z)

The `.scale` API allows a user to scale the Render Tree below. The scale transform looks like this:

```js
  [x, 0, 0, 0,
   0, y, 0, 0,
   0, 0, z, 0,
   0, 0, 0, 1]
```

#####Transform.rotateX(radians)
The x-rotation `Transform` results in a clockwise-rotation around the x-axis. It looks like

```js
  [1, 0, 0, 0,
   0, Math.cos(radians), Math.sin(-radians), 0,
   0, Math.sin(radians), Math.cos(radians), 0,
   0, 0 , 0, 1]
```

#####Transform.rotateY(radians)
Similarly, the Y rotation transform looks like this:

```js
  [Math.cos(radians), 0, Math.sin(radians), 0,
   0, 1, 0, 0,
   Math.sin(radians), 0, Math.cos(radians), 0,
   0, 0, 0, 1]
```

#####Transform.rotateZ(radians)
Similarly, the Y rotation transform looks like this:Z rotation transform looks like this:

```js
  [Math.cos(radians), Math.sin(-radians), 0, 0,
   Math.sin(radians), Math.cos(radians), 0, 0,
   0, 0, 1, 0,
   0, 0, 0, 1]
```

#####Transform.multiply()

`Transforms` can be composed via the multiplication method, which takes two `Transforms` as arguments. Note: multiplication is not commutative! A translation following by a rotation is not the same as a rotation followed by a translation, for instance.

```js
  Transform.multiply(
    Transform.translate(100,0,0),
    Transform.rotateZ(Math.PI/4)
  );
```


<a name="size">Size</a>
--------------------------------------------------------------------------------
`Size` defines a bounding-box for content. Nodes in the Render Tree below sized `Modifiers` can 
use this bounding size to lay themselves out. The simplest example being a `Surface` that takes on the size
of a parenting `Modifier` by setting its own `size` to `undefined`. In the following example, the created
surfaces will have a width of 200, which it inherits from the `Modifier` above it.

```js
  var sizeModifier = new Modifier({size : [200,200]});
  var surface = new Surface({
    size : [undefined, 100], 
    properties : {background : 'red'}
  });
  context.add(sizeModifier).add(surface);
```

Views like `Scrollview` and `GridLayout` use the size of sequenced renderables in order
to translate them by the width or height of preceding renderables. If, for some reason,
you wanted a surface to occupy a larger or smaller size in famo.us internals, without
changing the actual size of the DOM element, you can add it after a modifier with a
size property, e.g.

For a more specific example, sequencing from an array of views with the sized modifier
paradigm can produce a spacing effect:

```js
  //gives you a buffer of ten pixels at the bottom of every renderable
  var views = [];
  for (i = 0; i < 5; i++) {
    var view = new View();
    var sizedModifier = new Modifier({
        size:  [undefined, 110]
      })
    var surface = new Surface({
      properties: {
        background: 'red'
      },
      size: [undefined, 100]
    })
    view.add(sizeModifier).add(surface);
  }
  scrollview.sequenceFrom(views);
```

Internally, views that use size rely upon calling their renderables' getSize method.
Generally, you can safely size renderables without having to concern yourself with
the getSize method, except when dealing with a view with branches. In that case,
the recommended pattern is to overwrite the views' getSize method, either through subclassing,
our through overwriting the property, e.g.

```js
  var view = new View();
  var firstBranchModifier = new Modifier({
      size:  [100, 110]
  })
  var firstBranchsurface = new Surface({
    properties: {
      background: 'red'
    },
    size: [100, 100]
  })
  var secondBranchModifier = new Modifier({
      transform: Transform.translate(0, firstBranchModifier.getSize())
  })
  var secondBranchsurface = new Surface({
    properties: {
      background: 'blue'
    },
    size: [100, 100]
  })
  view.add(firstBranchModifier).add(firstBranchSurface);
  view.add(secondBranchModifier).add(secondBranchSurface);

  view.getSize = function() {
    //returns the combined size of the two surfaces
    return [100, 210]
  }

```

<a name="origin">Origin</a>
--------------------------------------------------------------------------------
Origin interacts with both `size` and `Transforms`. The internal implementation of origin
is that origin is multiplied against the size of the parent (defaults to [window.innerWidth, window.innerHeight]
if you don't specify a size in any preceding modifier) and used to apply a moveThen and an
aboutOrigin transform to the transform of the child. This has the visual effect of applying transforms about
a certain point of the parent size. For instance:

```js
    var test = new Surface({
        size: [100, 100],
        properties: {
            background: 'red'
        },
    });

    var originMod = new Modifier({
        origin: [1, 0]
    });

    var sizeMod = new Modifier({
        size: [100, 100]
    });

    var rotateMod = new Modifier();

    var rotateTransition = {
        duration: 800,
    };

    mainContext.add(sizeMod).add(originMod).add(rotateMod).add(test);

    rotateMod.setTransform(Transform.rotateY(Math.PI * 0.4), rotateTransition);
```

In this example, we're applying an origin point of the opposite side to a rotation transform
with respect to a parent size context equal to the size of the surface. This has the visual effect of rotating from
the opposite side of the surface.

#####Origin and size
Part of how origin affects subsequent transforms is a moveThen multiplication, which
has an element of translation, specifically x and y translation as a function of multiplying
origin against the size of its parent context. This conveniently allows you to use origin
for positioning as well as things like rotating around a different origin axis. For example:

```js
  var sizeMod = new Modifier({
    size: [window.innerWidth * 0.5, window.innerHeight * 0.5]
  });
  var originMod = new Modifier({
    origin: [0.5, 0.5]
  });
  var test = new Surface({
      size: [100, 100],
      properties: {
          background: 'red'
      },
  });
  mainContext.add(sizeMod).add(originMod).add(test);
```

In this example, we're centering text to an area half the size of your screen, positioning
the surface in the top left corner. Had we not specified a size, the surface would've
appeared in the center of the screen, as the parent context size defaults to [window.innerWidth, window.innerHeight].

```js
  var sizeMod = new Modifier({
    size: [window.innerWidth * 0.5, window.innerHeight * 0.5]
  });
  var originMod = new Modifier({
    origin: [0.5, 0.5]
  });
  var firstOriginMod = new Modifier({
    origin: [0.5, 0.5]
  })
  var test = new Surface({
      size: [100, 100],
      properties: {
          background: 'red'
      },
  });
  mainContext.add(firstOriginMod).add(sizeMod).add(originMod).add(test);
```

Now our surface appears in the center of the screen, as the smaller size context we were
setting tests' origin point from has also been centered.

#####Origin and transforms
As we saw in the first example, origin can be used to modify the origin point of transforms
when placed before them in an add chain. However, the interaction of applying a transform to an
origin is important and distinct, as well.

```js
var test = new Surface({
    size: [100, 100],
    properties: {
        background: 'red'
    },
});

var originMod = new Modifier({
    origin: [1, 0]
});

var sizeMod = new Modifier({
    size: [500, 500]
});

var rotateMod = new Modifier();

var rotateTransition = {
    duration: 800,
};

mainContext.add(sizeMod).add(rotateMod).add(originMod).add(test);

rotateMod.setTransform(Transform.rotateY(Math.PI * 0.4), rotateTransition);
```

Now we see test rotating backwards in z space in an arc. What's occurring is that the rotateMod's
rotation transform is being multiplied against the translation supplied by origin (translating
it to the opposite side of the parent context), and as discussed in the transforms section
a translation is applied from the surface's perspective, so as it rotates, it's forward
direction changes. If you think of origin as a special transform which applies both
translation and modification of the origin point of subsequent transforms, these interactions
become a lot more clear.

<a name="review">Review</a>
--------------------------------------------------------------------------------
In this section, we learned that all layout in Famo.us is directed by transforms.
Size is used by higher-level views to know how to layout renderables with translation,
and also to enable the special origin transform. Origin can be used to both position
child renderables with respect to their parent context, and to change the origin point
child transforms are applied around.
